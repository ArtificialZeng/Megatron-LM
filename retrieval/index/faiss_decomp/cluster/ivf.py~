# lawrence mcafee

# ~~~~~~~~ import ~~~~~~~~
import faiss
import os

from lutil import pax

import lawrence.utils as utils

from lawrence.index import Index

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# class IVFStage(Index):
class IVFIndex(Index):

    def __init__(self, args, d, nlist):
        super().__init__(args, d)

        self.nlist = nlist
        self.ivf = faiss.IndexIVFFlat(faiss.IndexFlatL2(d), d, nlist)

    def dout(self):
        return self.din()

    def verbose(self, v):
        self.c_verbose(self.ivf, v)
        # self.c_verbose(self.quantizer, v)

    def train(self, input_data_path, dir_path, timer):

        empty_index_path = self.get_empty_index_path(dir_path)
        output_data_path = self.get_output_data_path(dir_path)

        # pax({
        #     "empty_index_path" : empty_index_path,
        #     "input_data_path" : input_data_path,
        #     "output_data_path" : output_data_path,
        # })

        if not os.path.isfile(empty_index_path):

            timer.push("train")
            inp = utils.load_data(input_data_path)["data"]
            self.ivf.train(inp)
            faiss.write_index(self.ivf, empty_index_path)
            timer.pop()

        if not os.path.isfile(output_data_path):

            timer.push("forward")

            self.ivf = faiss.read_index(empty_index_path)
            centroids = self.ivf.quantizer.reconstruct_n(0, 10)

            # >>>
            # q = self.ivf.quantizer
            # pax({
            #     "ivf" : self.ivf,
            #     "quantizer" : q,
            #     # "xb" : q.get_xb(),
            #     # "codes" : self.ivf.quantizer.codes,
            #     # "invlists" : self.ivf.invlists,
            #     # "recon" : self.ivf.quantizer.reconstruct(0),
            #     # "ntotal" : q.ntotal,
            #     "recon" : centroids,
            # })
            # <<<

            inp = utils.load_data(input_data_path)["data"]
            dists, centroid_ids = self.ivf.quantizer.search(inp, 1)

            utils.save_data({
                "data" : inp,
                "centroids" : centroids,
                "centroid_ids" : centroid_ids,
            }, output_data_path)

            timer.pop()

        # pax({
        #     # "inp" : inp,
        #     # "out" : out,
        #     "data_map_0" : data_map_0,
        #     "data_map_1" : data_map_1,
        # })

        # return data_map_1
        return output_data_path

# eof
